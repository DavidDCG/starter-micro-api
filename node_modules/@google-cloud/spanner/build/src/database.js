"use strict";
/*!
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Database = void 0;
// eslint-disable-next-line @typescript-eslint/no-var-requires
const common = require('./common-grpc/service-object');
const promisify_1 = require("@google-cloud/promisify");
const extend = require("extend");
const streamEvents = require("stream-events");
const through = require("through2");
const google_gax_1 = require("google-gax");
const backup_1 = require("./backup");
const batch_transaction_1 = require("./batch-transaction");
const session_1 = require("./session");
const session_pool_1 = require("./session-pool");
const table_1 = require("./table");
const transaction_runner_1 = require("./transaction-runner");
const common_1 = require("./common");
const arrify = require("arrify");
const snakeCase = require("lodash.snakecase");
/**
 * Create a Database object to interact with a Cloud Spanner database.
 *
 * @class
 *
 * @param {string} name Name of the database.
 * @param {SessionPoolOptions|SessionPoolInterface} options Session pool
 *     configuration options or custom pool interface.
 * @param {google.spanner.v1.ExecuteSqlRequest.IQueryOptions} queryOptions
 *     The default query options to use for queries on the database.
 *
 * @example
 * ```
 * const {Spanner} = require('@google-cloud/spanner');
 * const spanner = new Spanner();
 * const instance = spanner.instance('my-instance');
 * const database = instance.database('my-database');
 * ```
 */
class Database extends common.GrpcServiceObject {
    constructor(instance, name, poolOptions, queryOptions) {
        const methods = {
            /**
             * Create a database.
             *
             * @method Database#create
             * @param {CreateDatabaseRequest} [options] Configuration object.
             * @param {CreateDatabaseCallback} [callback] Callback function.
             * @returns {Promise<CreateDatabaseResponse>}
             *
             * @example
             * ```
             * const {Spanner} = require('@google-cloud/spanner');
             * const spanner = new Spanner();
             * const instance = spanner.instance('my-instance');
             * const database = instance.database('my-database');
             *
             * database.create(function(err, database, operation, apiResponse) {
             *   if (err) {
             *     // Error handling omitted.
             *   }
             *
             *   operation
             *     .on('error', function(err) {})
             *     .on('complete', function() {
             *       // Database created successfully.
             *     });
             * });
             *
             * //-
             * // If the callback is omitted, we'll return a Promise.
             * //-
             * database.create()
             *   .then(function(data) {
             *     const operation = data[0];
             *     const apiResponse = data[1];
             *
             *     return operation.promise();
             *   })
             *   .then(function() {
             *     // Database created successfully.
             *   });
             * ```
             */
            create: true,
        };
        const formattedName_ = Database.formatName_(instance.formattedName_, name);
        super({
            parent: instance,
            id: name,
            methods,
            createMethod: (_, options, callback) => {
                const pool = this.pool_;
                if (pool._pending > 0) {
                    // If there are BatchCreateSessions requests pending, then we should
                    // wait until these have finished before we try to create the database.
                    // Otherwise the results of these requests might be propagated to
                    // client requests that are submitted after the database has been
                    // created. If the pending requests have not finished within 10 seconds,
                    // they will be ignored and the database creation will proceed.
                    let timeout;
                    const promises = [
                        new Promise(resolve => (timeout = setTimeout(resolve, 10000))),
                        new Promise(resolve => {
                            pool
                                .on('available', () => {
                                if (pool._pending === 0) {
                                    clearTimeout(timeout);
                                    resolve();
                                }
                            })
                                .on('createError', () => {
                                if (pool._pending === 0) {
                                    clearTimeout(timeout);
                                    resolve();
                                }
                            });
                        }),
                    ];
                    Promise.race(promises).then(() => instance.createDatabase(formattedName_, options, callback));
                }
                else {
                    return instance.createDatabase(formattedName_, options, callback);
                }
            },
        });
        this.pool_ =
            typeof poolOptions === 'function'
                ? new poolOptions(this, null)
                : new session_pool_1.SessionPool(this, poolOptions);
        if (typeof poolOptions === 'object') {
            this.databaseRole = poolOptions.databaseRole || null;
        }
        this.formattedName_ = formattedName_;
        this.instance = instance;
        this.resourceHeader_ = {
            [common_1.CLOUD_RESOURCE_HEADER]: this.formattedName_,
        };
        this.request = instance.request;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.requestStream = instance.requestStream;
        this.pool_.on('error', this.emit.bind(this, 'error'));
        this.pool_.open();
        this.queryOptions_ = Object.assign(Object.assign({}, queryOptions), Database.getEnvironmentQueryOptions());
    }
    setMetadata(metadata, optionsOrCallback, cb) {
        const gaxOpts = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;
        const reqOpts = {
            database: extend({
                name: this.formattedName_,
            }, metadata),
            updateMask: {
                paths: Object.keys(metadata).map(snakeCase),
            },
        };
        return this.request({
            client: 'DatabaseAdminClient',
            method: 'updateDatabase',
            reqOpts,
            gaxOpts,
            headers: this.resourceHeader_,
        }, callback);
    }
    static getEnvironmentQueryOptions() {
        const options = {};
        if (process.env.SPANNER_OPTIMIZER_VERSION) {
            options.optimizerVersion = process.env.SPANNER_OPTIMIZER_VERSION;
        }
        if (process.env.SPANNER_OPTIMIZER_STATISTICS_PACKAGE) {
            options.optimizerStatisticsPackage =
                process.env.SPANNER_OPTIMIZER_STATISTICS_PACKAGE;
        }
        return options;
    }
    batchCreateSessions(options, callback) {
        if (typeof options === 'number') {
            options = { count: options };
        }
        const count = options.count;
        const labels = options.labels || {};
        const databaseRole = options.databaseRole || this.databaseRole || null;
        const reqOpts = {
            database: this.formattedName_,
            sessionTemplate: { labels: labels, creatorRole: databaseRole },
            sessionCount: count,
        };
        const headers = this.resourceHeader_;
        if (this._getSpanner().routeToLeaderEnabled) {
            (0, common_1.addLeaderAwareRoutingHeader)(headers);
        }
        this.request({
            client: 'SpannerClient',
            method: 'batchCreateSessions',
            reqOpts,
            gaxOpts: options.gaxOptions,
            headers: headers,
        }, (err, resp) => {
            if (err) {
                callback(err, null, resp);
                return;
            }
            const sessions = (resp.session || []).map(metadata => {
                const session = this.session(metadata.name);
                session.metadata = metadata;
                return session;
            });
            callback(null, sessions, resp);
        });
    }
    /**
     * Get a reference to a {@link BatchTransaction} object.
     *
     * @see {@link BatchTransaction#identifier} to generate an identifier.
     *
     * @param {TransactionIdentifier} identifier The transaction identifier.
     * @param {object} [options] [Transaction options](https://cloud.google.com/spanner/docs/timestamp-bounds).
     * @returns {BatchTransaction} A batch transaction object.
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * const transaction = database.batchTransaction({
     *   session: 'my-session',
     *   transaction: 'my-transaction',
     *   readTimestamp: 1518464696657
     * });
     * ```
     */
    batchTransaction(identifier, options) {
        const session = typeof identifier.session === 'string'
            ? this.session(identifier.session)
            : identifier.session;
        const id = identifier.transaction;
        const transaction = new batch_transaction_1.BatchTransaction(session, options);
        transaction.id = id;
        transaction.readTimestamp = identifier.timestamp;
        return transaction;
    }
    close(callback) {
        const key = this.id.split('/').pop();
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.parent.databases_.delete(key);
        this.pool_.close(callback);
    }
    createBatchTransaction(optionsOrCallback, cb) {
        const callback = typeof optionsOrCallback === 'function'
            ? optionsOrCallback
            : cb;
        const options = typeof optionsOrCallback === 'object'
            ? optionsOrCallback
            : {};
        this.pool_.getSession((err, session) => {
            if (err) {
                callback(err, null, undefined);
                return;
            }
            const transaction = this.batchTransaction({ session: session }, options);
            this._releaseOnEnd(session, transaction);
            transaction.begin((err, resp) => {
                if (err) {
                    callback(err, null, resp);
                    return;
                }
                callback(null, transaction, resp);
            });
        });
    }
    createSession(optionsOrCallback, cb) {
        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;
        const options = typeof optionsOrCallback === 'object' && optionsOrCallback
            ? extend({}, optionsOrCallback)
            : {};
        const reqOpts = {
            database: this.formattedName_,
        };
        reqOpts.session = {};
        if (options.labels) {
            reqOpts.session.labels = options.labels;
        }
        reqOpts.session.creatorRole =
            options.databaseRole || this.databaseRole || null;
        const headers = this.resourceHeader_;
        if (this._getSpanner().routeToLeaderEnabled) {
            (0, common_1.addLeaderAwareRoutingHeader)(headers);
        }
        this.request({
            client: 'SpannerClient',
            method: 'createSession',
            reqOpts,
            gaxOpts: options.gaxOptions,
            headers: headers,
        }, (err, resp) => {
            if (err) {
                callback(err, null, resp);
                return;
            }
            const session = this.session(resp.name);
            session.metadata = resp;
            callback(null, session, resp);
        });
    }
    createTable(schema, gaxOptionsOrCallback, cb) {
        const gaxOptions = typeof gaxOptionsOrCallback === 'object' ? gaxOptionsOrCallback : {};
        const callback = typeof gaxOptionsOrCallback === 'function' ? gaxOptionsOrCallback : cb;
        this.updateSchema(schema, gaxOptions, (err, operation, resp) => {
            if (err) {
                callback(err, null, null, resp);
                return;
            }
            const tableName = schema.match(/CREATE TABLE `*([^\s`(]+)/)[1];
            const table = this.table(tableName);
            callback(null, table, operation, resp);
        });
    }
    /**
     * Decorates transaction so that when end() is called it will return the session
     * back into the pool.
     *
     * @private
     *
     * @param {Session} session The session to release.
     * @param {Transaction} transaction The transaction to observe.
     * @returns {Transaction}
     */
    _releaseOnEnd(session, transaction) {
        transaction.once('end', () => {
            try {
                this.pool_.release(session);
            }
            catch (e) {
                this.emit('error', e);
            }
        });
    }
    delete(optionsOrCallback, cb) {
        const gaxOpts = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;
        const reqOpts = {
            database: this.formattedName_,
        };
        this.close(() => {
            this.request({
                client: 'DatabaseAdminClient',
                method: 'dropDatabase',
                reqOpts,
                gaxOpts,
                headers: this.resourceHeader_,
            }, callback);
        });
    }
    exists(gaxOptionsOrCallback, cb) {
        const gaxOptions = typeof gaxOptionsOrCallback === 'object' ? gaxOptionsOrCallback : {};
        const callback = typeof gaxOptionsOrCallback === 'function' ? gaxOptionsOrCallback : cb;
        const NOT_FOUND = 5;
        this.getMetadata(gaxOptions, err => {
            if (err && err.code !== NOT_FOUND) {
                callback(err);
                return;
            }
            const exists = !err || err.code !== NOT_FOUND;
            callback(null, exists);
        });
    }
    get(optionsOrCallback, cb) {
        const options = typeof optionsOrCallback === 'object'
            ? optionsOrCallback
            : {};
        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;
        this.getMetadata(options.gaxOptions, (err, metadata) => {
            if (err) {
                if (options.autoCreate && err.code === 5) {
                    this.create(options, (err, database, operation) => {
                        if (err) {
                            callback(err);
                            return;
                        }
                        operation
                            .on('error', callback)
                            .on('complete', (metadata) => {
                            this.metadata = metadata;
                            callback(null, this, metadata);
                        });
                    });
                    return;
                }
                callback(err);
                return;
            }
            callback(null, this, metadata);
        });
    }
    getMetadata(gaxOptionsOrCallback, cb) {
        const callback = typeof gaxOptionsOrCallback === 'function'
            ? gaxOptionsOrCallback
            : cb;
        const gaxOpts = typeof gaxOptionsOrCallback === 'object'
            ? gaxOptionsOrCallback
            : {};
        const reqOpts = {
            name: this.formattedName_,
        };
        return this.request({
            client: 'DatabaseAdminClient',
            method: 'getDatabase',
            reqOpts,
            gaxOpts,
            headers: this.resourceHeader_,
        }, (err, resp) => {
            if (resp) {
                this.metadata = resp;
            }
            callback(err, resp);
        });
    }
    async getRestoreInfo(optionsOrCallback) {
        const gaxOptions = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        const [metadata] = await this.getMetadata(gaxOptions);
        return metadata.restoreInfo ? metadata.restoreInfo : undefined;
    }
    async getState(optionsOrCallback) {
        const gaxOptions = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        const [metadata] = await this.getMetadata(gaxOptions);
        return metadata.state || undefined;
    }
    getSchema(optionsOrCallback, cb) {
        const gaxOpts = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;
        const reqOpts = {
            database: this.formattedName_,
        };
        this.request({
            client: 'DatabaseAdminClient',
            method: 'getDatabaseDdl',
            reqOpts,
            gaxOpts,
            headers: this.resourceHeader_,
        }, 
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (err, statements, ...args) => {
            callback(err, statements ? statements.statements : null, ...args);
        });
    }
    getIamPolicy(optionsOrCallback, cb) {
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;
        const reqOpts = {
            resource: this.formattedName_,
            options: {
                requestedPolicyVersion: options.requestedPolicyVersion || null,
            },
        };
        this.request({
            client: 'DatabaseAdminClient',
            method: 'getIamPolicy',
            reqOpts,
            gaxOpts: options.gaxOptions,
            headers: this.resourceHeader_,
        }, (err, resp) => {
            callback(err, resp);
        });
    }
    getSessions(optionsOrCallback, cb) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;
        const options = typeof optionsOrCallback === 'object'
            ? optionsOrCallback
            : {};
        const gaxOpts = extend(true, {}, options.gaxOptions);
        let reqOpts = extend({}, options, {
            database: this.formattedName_,
        });
        delete reqOpts.gaxOptions;
        // Copy over pageSize and pageToken values from gaxOptions.
        // However values set on options take precedence.
        if (gaxOpts) {
            reqOpts = extend({}, {
                pageSize: gaxOpts.pageSize,
                pageToken: gaxOpts.pageToken,
            }, reqOpts);
            delete gaxOpts.pageSize;
            delete gaxOpts.pageToken;
        }
        this.request({
            client: 'SpannerClient',
            method: 'listSessions',
            reqOpts,
            gaxOpts,
            headers: this.resourceHeader_,
        }, (err, sessions, nextPageRequest, ...args) => {
            let sessionInstances = null;
            if (sessions) {
                sessionInstances = sessions.map(metadata => {
                    const session = self.session(metadata.name);
                    session.metadata = metadata;
                    return session;
                });
            }
            const nextQuery = nextPageRequest
                ? extend({}, options, nextPageRequest)
                : null;
            callback(err, sessionInstances, nextQuery, ...args);
        });
    }
    /**
     * Get a list of sessions as a readable object stream.
     *
     * Wrapper around {@link v1.SpannerClient#listSessions}
     *
     * @see {@link v1.SpannerClient#listSessions}
     * @see [ListSessions API Documentation](https://cloud.google.com/spanner/docs/reference/rpc/google.spanner.v1#google.spanner.v1.Spanner.ListSessions)
     *
     * @method Spanner#getSessionsStream
     * @param {GetSessionsOptions} [options] Options object for listing sessions.
     * @returns {ReadableStream} A readable stream that emits {@link Session}
     *     instances.
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * database.getSessionsStream()
     *   .on('error', console.error)
     *   .on('data', function(database) {
     *     // `sessions` is a `Session` object.
     *   })
     *   .on('end', function() {
     *     // All sessions retrieved.
     *   });
     *
     * //-
     * // If you anticipate many results, you can end a stream early to prevent
     * // unnecessary processing and API requests.
     * //-
     * database.getSessionsStream()
     *   .on('data', function(session) {
     *     this.end();
     *   });
     * ```
     */
    getSessionsStream(options = {}) {
        const gaxOpts = extend(true, {}, options.gaxOptions);
        let reqOpts = extend({}, options, {
            database: this.formattedName_,
        });
        delete reqOpts.gaxOptions;
        // Copy over pageSize and pageToken values from gaxOptions.
        // However values set on options take precedence.
        if (gaxOpts) {
            reqOpts = extend({}, {
                pageSize: gaxOpts.pageSize,
                pageToken: gaxOpts.pageToken,
            }, reqOpts);
            delete gaxOpts.pageSize;
            delete gaxOpts.pageToken;
        }
        return this.requestStream({
            client: 'SpannerClient',
            method: 'listSessionsStream',
            reqOpts,
            gaxOpts,
            headers: this.resourceHeader_,
        });
    }
    getSnapshot(optionsOrCallback, cb) {
        const callback = typeof optionsOrCallback === 'function'
            ? optionsOrCallback
            : cb;
        const options = typeof optionsOrCallback === 'object'
            ? optionsOrCallback
            : {};
        this.pool_.getSession((err, session) => {
            if (err) {
                callback(err);
                return;
            }
            const snapshot = session.snapshot(options, this.queryOptions_);
            snapshot.begin(err => {
                if (err) {
                    if ((0, session_pool_1.isSessionNotFoundError)(err)) {
                        session.lastError = err;
                        this.pool_.release(session);
                        this.getSnapshot(options, callback);
                    }
                    else {
                        this.pool_.release(session);
                        callback(err);
                    }
                    return;
                }
                this._releaseOnEnd(session, snapshot);
                callback(err, snapshot);
            });
        });
    }
    getTransaction(callback) {
        this.pool_.getSession((err, session, transaction) => {
            if (!err) {
                this._releaseOnEnd(session, transaction);
            }
            callback(err, transaction);
        });
    }
    async getOperations(optionsOrCallback) {
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        // Create a query that lists database operations only on this database from
        // the instance. Operation name will be prefixed with the database path for
        // all operations on this database
        let dbSpecificFilter = `name:${this.formattedName_}`;
        if (options && options.filter) {
            dbSpecificFilter = `(${dbSpecificFilter}) AND (${options.filter})`;
        }
        const dbSpecificQuery = {
            ...options,
            filter: dbSpecificFilter,
        };
        return this.instance.getDatabaseOperations(dbSpecificQuery);
    }
    getDatabaseRoles(optionsOrCallback, cb) {
        const gaxOpts = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;
        let reqOpts = {
            parent: this.formattedName_,
        };
        // Copy over pageSize and pageToken values from gaxOptions.
        // However, values set on options take precedence.
        if (gaxOpts) {
            reqOpts = extend({}, {
                pageSize: gaxOpts.pageSize,
                pageToken: gaxOpts.pageToken,
            }, reqOpts);
            delete gaxOpts.pageSize;
            delete gaxOpts.pageToken;
        }
        this.request({
            client: 'DatabaseAdminClient',
            method: 'listDatabaseRoles',
            reqOpts,
            gaxOpts,
            headers: this.resourceHeader_,
        }, (err, roles, nextPageRequest, ...args) => {
            const nextQuery = nextPageRequest
                ? extend({}, gaxOpts, nextPageRequest)
                : null;
            callback(err, roles, nextQuery, ...args);
        });
    }
    makePooledRequest_(config, callback) {
        const pool = this.pool_;
        pool.getSession((err, session) => {
            if (err) {
                callback(err, null);
                return;
            }
            config.reqOpts.session = session.formattedName_;
            this.request(config, (err, ...args) => {
                pool.release(session);
                callback(err, ...args);
            });
        });
    }
    /**
     * Make an API request as a stream, first assuring an active session is used.
     *
     * @private
     *
     * @param {object} config Request config
     * @returns {Stream}
     */
    makePooledStreamingRequest_(config) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        const pool = this.pool_;
        let requestStream;
        let session;
        const waitForSessionStream = streamEvents(through.obj());
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        waitForSessionStream.abort = () => {
            releaseSession();
            if (requestStream) {
                requestStream.cancel();
            }
        };
        function destroyStream(err) {
            waitForSessionStream.destroy(err);
        }
        function releaseSession() {
            if (session) {
                pool.release(session);
                session = null;
            }
        }
        waitForSessionStream.on('reading', () => {
            pool.getSession((err, session_) => {
                if (err) {
                    destroyStream(err);
                    return;
                }
                session = session_;
                config.reqOpts.session = session.formattedName_;
                requestStream = self.requestStream(config);
                requestStream
                    .on('error', releaseSession)
                    .on('error', destroyStream)
                    .on('end', releaseSession)
                    .pipe(waitForSessionStream);
            });
        });
        return waitForSessionStream;
    }
    restore(backupName, optionsOrCallback, cb) {
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        const callback = typeof optionsOrCallback === 'function'
            ? optionsOrCallback
            : cb;
        const gaxOpts = 'gaxOptions' in options
            ? options.gaxOptions
            : options;
        const reqOpts = {
            parent: this.instance.formattedName_,
            databaseId: this.id,
            backup: backup_1.Backup.formatName_(this.instance.formattedName_, backupName),
        };
        if ('encryptionConfig' in options &&
            options.encryptionConfig) {
            reqOpts.encryptionConfig = options.encryptionConfig;
        }
        return this.request({
            client: 'DatabaseAdminClient',
            method: 'restoreDatabase',
            reqOpts,
            gaxOpts,
            headers: this.resourceHeader_,
        }, (err, operation, resp) => {
            if (err) {
                callback(err, null, null, resp);
                return;
            }
            callback(null, this, operation, resp);
        });
    }
    run(query, optionsOrCallback, cb) {
        let stats;
        let metadata;
        const rows = [];
        const callback = typeof optionsOrCallback === 'function'
            ? optionsOrCallback
            : cb;
        const options = typeof optionsOrCallback === 'object'
            ? optionsOrCallback
            : {};
        this.runStream(query, options)
            .on('error', callback)
            .on('response', response => {
            if (response.metadata) {
                metadata = response.metadata;
            }
        })
            .on('stats', _stats => (stats = _stats))
            .on('data', row => {
            rows.push(row);
        })
            .on('end', () => {
            callback(null, rows, stats, metadata);
        });
    }
    runPartitionedUpdate(query, callback) {
        this.pool_.getSession((err, session) => {
            if (err) {
                callback(err, 0);
                return;
            }
            this._runPartitionedUpdate(session, query, callback);
        });
    }
    _runPartitionedUpdate(session, query, callback) {
        const transaction = session.partitionedDml();
        transaction.begin(err => {
            if (err) {
                this.pool_.release(session);
                callback(err, 0);
                return;
            }
            transaction.runUpdate(query, (err, updateCount) => {
                if (err) {
                    if (err.code !== google_gax_1.grpc.status.ABORTED) {
                        this.pool_.release(session);
                        callback(err, 0);
                        return;
                    }
                    this._runPartitionedUpdate(session, query, callback);
                }
                else {
                    this.pool_.release(session);
                    callback(null, updateCount);
                    return;
                }
            });
        });
    }
    /**
     * Create a readable object stream to receive resulting rows from a SQL
     * statement.
     *
     * Wrapper around {@link v1.SpannerClient#executeStreamingSql}.
     *
     * @see {@link v1.SpannerClient#executeStreamingSql}
     * @see [Query Syntax](https://cloud.google.com/spanner/docs/query-syntax)
     * @see [ExecuteSql API Documentation](https://cloud.google.com/spanner/docs/reference/rpc/google.spanner.v1#google.spanner.v1.Spanner.ExecuteSql)
     *
     * @fires PartialResultStream#response
     *
     * @param {string|ExecuteSqlRequest} query A SQL query or
     *     {@link ExecuteSqlRequest} object.
     * @param {TimestampBounds} [options] Snapshot timestamp bounds.
     * @returns {PartialResultStream} A readable stream that emits rows.
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * const query = 'SELECT * FROM Singers';
     *
     * database.runStream(query)
     *   .on('error', function(err) {})
     *   .on('data', function(row) {
     *     // row = [
     *     //   {
     *     //     name: 'SingerId',
     *     //     value: '1'
     *     //   },
     *     //   {
     *     //     name: 'Name',
     *     //     value: 'Eddie Wilson'
     *     //   }
     *     // ]
     *   // ]
     *   })
     *   .on('end', function() {
     *     // All results retrieved.
     *   });
     *
     * //-
     * // Rows are returned as an array of objects. Each object has a `name` and
     * // `value` property. To get a serialized object, call `toJSON()`.
     * //-
     * database.runStream(query)
     *   .on('error', function(err) {})
     *   .on('data', function(row) {
     *     // row.toJSON() = {
     *     //   SingerId: '1',
     *     //   Name: 'Eddie Wilson'
     *     // }
     *   })
     *   .on('end', function() {
     *     // All results retrieved.
     *   });
     *
     * //-
     * // Alternatively, set `query.json` to `true`, and this step will be performed
     * // automatically.
     * //-
     * query.json = true;
     *
     * database.runStream(query)
     *   .on('error', function(err) {})
     *   .on('data', function(row) {
     *     // row = {
     *     //   SingerId: '1',
     *     //   Name: 'Eddie Wilson'
     *     // }
     *   })
     *   .on('end', function() {
     *     // All results retrieved.
     *   });
     *
     * //-
     * // The SQL query string can contain parameter placeholders. A parameter
     * // placeholder consists of '@' followed by the parameter name.
     * //-
     * const query = {
     *   sql: 'SELECT * FROM Singers WHERE name = @name',
     *   params: {
     *     name: 'Eddie Wilson'
     *   }
     * };
     *
     * database.runStream(query)
     *   .on('error', function(err) {})
     *   .on('data', function(row) {})
     *   .on('end', function() {});
     *
     * //-
     * // If you need to enforce a specific param type, a types map can be provided.
     * // This is typically useful if your param value can be null.
     * //-
     * const query = {
     *   sql: 'SELECT * FROM Singers WHERE name = @name',
     *   params: {
     *     name: 'Eddie Wilson'
     *   },
     *   types: {
     *     name: 'string'
     *   }
     * };
     *
     * database.runStream(query)
     *   .on('error', function(err) {})
     *   .on('data', function(row) {})
     *   .on('end', function() {});
     *
     * //-
     * // If you anticipate many results, you can end a stream early to prevent
     * // unnecessary processing and API requests.
     * //-
     * database.runStream(query)
     *   .on('data', function(row) {
     *     this.end();
     *   });
     * ```
     */
    runStream(query, options) {
        const proxyStream = through.obj();
        this.pool_.getSession((err, session) => {
            if (err) {
                proxyStream.destroy(err);
                return;
            }
            const snapshot = session.snapshot(options, this.queryOptions_);
            this._releaseOnEnd(session, snapshot);
            let dataReceived = false;
            let dataStream = snapshot.runStream(query);
            const endListener = () => snapshot.end();
            dataStream
                .once('data', () => (dataReceived = true))
                .once('error', err => {
                if (!dataReceived &&
                    (0, session_pool_1.isSessionNotFoundError)(err)) {
                    // If it is a 'Session not found' error and we have not yet received
                    // any data, we can safely retry the query on a new session.
                    // Register the error on the session so the pool can discard it.
                    if (session) {
                        session.lastError = err;
                    }
                    // Remove the current data stream from the end user stream.
                    dataStream.unpipe(proxyStream);
                    dataStream.removeListener('end', endListener);
                    dataStream.end();
                    snapshot.end();
                    // Create a new data stream and add it to the end user stream.
                    dataStream = this.runStream(query, options);
                    dataStream.pipe(proxyStream);
                }
                else {
                    proxyStream.destroy(err);
                    snapshot.end();
                }
            })
                .on('stats', stats => proxyStream.emit('stats', stats))
                .on('response', response => proxyStream.emit('response', response))
                .once('end', endListener)
                .pipe(proxyStream);
        });
        return proxyStream;
    }
    runTransaction(optionsOrRunFn, fn) {
        const runFn = typeof optionsOrRunFn === 'function'
            ? optionsOrRunFn
            : fn;
        const options = typeof optionsOrRunFn === 'object' && optionsOrRunFn
            ? optionsOrRunFn
            : {};
        this.pool_.getSession((err, session, transaction) => {
            if (err && (0, session_pool_1.isSessionNotFoundError)(err)) {
                this.runTransaction(options, runFn);
                return;
            }
            if (err) {
                runFn(err);
                return;
            }
            if (options.optimisticLock) {
                transaction.useOptimisticLock();
            }
            const release = this.pool_.release.bind(this.pool_, session);
            const runner = new transaction_runner_1.TransactionRunner(session, transaction, runFn, options);
            runner.run().then(release, err => {
                if ((0, session_pool_1.isSessionNotFoundError)(err)) {
                    release();
                    this.runTransaction(options, runFn);
                }
                else {
                    setImmediate(runFn, err);
                    release();
                }
            });
        });
    }
    /**
     * @callback AsyncRunTransactionCallback
     * @param {Transaction} transaction The transaction object. The transaction has
     *     already been created, and is ready to be queried and committed against.
     */
    /**
     * A transaction in Cloud Spanner is a set of reads and writes that execute
     * atomically at a single logical point in time across columns, rows, and tables
     * in a database.
     *
     * Note that Cloud Spanner does not support nested transactions. If a new
     * transaction is started inside of the run function, it will be an independent
     * transaction.
     *
     * The async function you provide will become the "run function". It
     * will be executed with a {@link Transaction}
     * object. The Transaction object will let you run queries and queue mutations
     * until you are ready to {@link Transaction#commit}.
     *
     * In the event that an aborted error occurs, we will re-run the `runFn` in its
     * entirety. If you prefer to handle aborted errors for yourself please refer to
     * {@link Database#getTransaction}.
     *
     * **NOTE:** In the event that you encounter an error while reading/writing,
     * if you decide to forgo calling {@link Transaction#commit} or
     * {@link Transaction#rollback}, then you need to call
     * {@link Transaction#end} to release the underlying {@link Session} object.
     * **Failure to do could result in a Session leak.**
     *
     * For a more complete listing of functionality available to a Transaction, see
     * the {@link Transaction} API documentation. For a general overview of
     * transactions within Cloud Spanner, see
     * [Transactions](https://cloud.google.com/spanner/docs/transactions) from the
     * official Cloud Spanner documentation.
     *
     * @see [Transactions](https://cloud.google.com/spanner/docs/transactions)
     *
     * @param {RunTransactionOptions} [options] Transaction runner options.
     * @param {AsyncRunTransactionCallback} callback A function to execute in the
     *      context of a transaction.
     * @returns {Promise}
     *
     * @example
     * ```
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * const data = await database.runTransactionAsync(async (transaction) => {
     *   const [rows] = await transaction.run('SELECT * FROM MyTable');
     *   const data = rows.map(row => row.thing);
     *
     *   await transaction.commit();
     *   return data;
     * });
     * ```
     */
    async runTransactionAsync(optionsOrRunFn, fn) {
        const runFn = typeof optionsOrRunFn === 'function'
            ? optionsOrRunFn
            : fn;
        const options = typeof optionsOrRunFn === 'object'
            ? optionsOrRunFn
            : {};
        const getSession = this.pool_.getSession.bind(this.pool_);
        // Loop to retry 'Session not found' errors.
        // (and yes, we like while (true) more than for (;;) here)
        // eslint-disable-next-line no-constant-condition
        while (true) {
            try {
                const [session, transaction] = await (0, promisify_1.promisify)(getSession)();
                transaction.requestOptions = Object.assign(transaction.requestOptions || {}, options.requestOptions);
                if (options.optimisticLock) {
                    transaction.useOptimisticLock();
                }
                const runner = new transaction_runner_1.AsyncTransactionRunner(session, transaction, runFn, options);
                try {
                    return await runner.run();
                }
                finally {
                    this.pool_.release(session);
                }
            }
            catch (e) {
                if (!(0, session_pool_1.isSessionNotFoundError)(e)) {
                    throw e;
                }
            }
        }
    }
    /**
     * Create a Session object.
     *
     * It is unlikely you will need to interact with sessions directly. By default,
     * sessions are created and utilized for maximum performance automatically.
     *
     * @param {string} [name] The name of the session. If not provided, it is
     *     assumed you are going to create it.
     * @returns {Session} A Session object.
     *
     * @example
     * ```
     * var session = database.session('session-name');
     * ```
     */
    session(name) {
        return new session_1.Session(this, name);
    }
    setIamPolicy(policy, optionsOrCallback, cb) {
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        const callback = typeof optionsOrCallback === 'function'
            ? optionsOrCallback
            : cb;
        const gaxOpts = options;
        const reqOpts = {
            resource: this.formattedName_,
            policy: policy.policy,
            updateMask: policy.updateMask || null,
        };
        this.request({
            client: 'DatabaseAdminClient',
            method: 'setIamPolicy',
            reqOpts,
            gaxOpts: gaxOpts,
            headers: this.resourceHeader_,
        }, (err, resp) => {
            callback(err, resp);
        });
    }
    table(name) {
        if (!name) {
            throw new google_gax_1.GoogleError('A name is required to access a Table object.');
        }
        return new table_1.Table(this, name);
    }
    updateSchema(statements, optionsOrCallback, cb) {
        const gaxOpts = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;
        if (typeof statements === 'string' || Array.isArray(statements)) {
            statements = {
                statements: arrify(statements),
            };
        }
        const reqOpts = extend({
            database: this.formattedName_,
        }, statements);
        return this.request({
            client: 'DatabaseAdminClient',
            method: 'updateDatabaseDdl',
            reqOpts,
            gaxOpts,
            headers: this.resourceHeader_,
        }, callback);
    }
    /**
     * Format the database name to include the instance name.
     *
     * @private
     *
     * @param {string} instanceName The formatted instance name.
     * @param {string} name The table name.
     * @returns {string}
     *
     * @example
     * ```
     * Database.formatName_(
     *   'projects/grape-spaceship-123/instances/my-instance',
     *   'my-database'
     * );
     * // 'projects/grape-spaceship-123/instances/my-instance/databases/my-database'
     * ```
     */
    static formatName_(instanceName, name) {
        if (name.indexOf('/') > -1) {
            return name;
        }
        const databaseName = name.split('/').pop();
        return instanceName + '/databases/' + databaseName;
    }
    /**
     * Gets the Spanner object
     *
     * @private
     *
     * @returns {Spanner}
     */
    _getSpanner() {
        return this.instance.parent;
    }
}
exports.Database = Database;
/*! Developer Documentation
 *
 * All async methods (except for streams) will return a Promise in the event
 * that a callback is omitted.
 */
(0, promisify_1.promisifyAll)(Database, {
    exclude: [
        'batchTransaction',
        'getRestoreInfo',
        'getState',
        'getOperations',
        'runTransaction',
        'runTransactionAsync',
        'table',
        'session',
    ],
});
/*! Developer Documentation
 *
 * All async methods (except for streams) will return a Promise in the event
 * that a callback is omitted.
 */
(0, promisify_1.callbackifyAll)(Database, {
    exclude: [
        'create',
        'batchCreateSessions',
        'batchTransaction',
        'close',
        'createBatchTransaction',
        'createSession',
        'createTable',
        'delete',
        'exists',
        'get',
        'getMetadata',
        'getSchema',
        'getSessions',
        'getSnapshot',
        'getTransaction',
        'getIamPolicy',
        'restore',
        'run',
        'runPartitionedUpdate',
        'runTransaction',
        'runTransactionAsync',
        'session',
        'setMetadata',
        'table',
        'updateSchema',
    ],
});
//# sourceMappingURL=database.js.map